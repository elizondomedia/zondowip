<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zondo Visualizer</title>
  <style>
    /* Full-screen static background image (GIF) */
    body {
      margin: 0;
      padding: 0;
      background: url("background.gif") no-repeat center center fixed;
      background-size: cover;
    }
    /* Center container for content */
    #visualizer-container {
      position: relative;
      text-align: center;
      color: #fff;
      z-index: 1; /* ensure content is above background */
    }
    /* The pulsing GIF image */
    #pulseGif {
      max-width: 50%;
      height: auto;
      /* Center the GIF horizontally */
      margin: 20px auto;
      display: block;
      /* Smooth transform changes slightly for pulsing (optional) */
      transition: transform 0.1s linear;
    }
  </style>
</head>
<body>
  <!-- Visualizer UI Container -->
  <div id="visualizer-container">
    <h1>Zondo Visualizer</h1>
    <!-- GIF selection UI -->
    <p>
      Select a GIF: 
      <select id="gifSelector">
        <!-- Add your GIF options here -->
        <option value="visual1.gif">Visual 1</option>
        <option value="visual2.gif">Visual 2</option>
        <option value="visual3.gif">Visual 3</option>
      </select>
      <button id="selectGifBtn">Load GIF</button>
    </p>
    <!-- The image element that will pulse with audio -->
    <img id="pulseGif" src="visual1.gif" alt="Visualizer GIF" />
    <!-- Button to start microphone capture -->
    <p>
      <button id="startBtn">ðŸŽ¤ Start Microphone Visualizer</button>
    </p>
  </div>

  <script>
    let audioCtx, analyser, dataArray, freqArray;
    let animationId;  // will hold the requestAnimationFrame ID
    const pulseImg = document.getElementById('pulseGif');

    // Set up event listeners for buttons
    document.getElementById('selectGifBtn').addEventListener('click', () => {
      const gifURL = document.getElementById('gifSelector').value;
      pulseImg.src = gifURL;  // update the GIF image source
      // The new GIF will start animating automatically
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      startMicVisualizer();
    });

    function startMicVisualizer() {
      // Prevent multiple initializations
      if (audioCtx) {
        return;  // already started
      }
      // Request access to the microphone audio stream
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Create AudioContext and Analyser
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 256;  // FFT size determines frequency resolution
          const bufferLength = analyser.frequencyBinCount;  // half of fftSize
          dataArray = new Uint8Array(bufferLength);
          freqArray = new Uint8Array(bufferLength);
          // Connect the audio source to the analyser node
          source.connect(analyser);

          // Start the animation loop for visualization
          animateVisualizer();
        })
        .catch(err => {
          console.error("Microphone access denied or error:", err);
          alert("Unable to access the microphone. Please check permissions.");
        });
    }

    function animateVisualizer() {
      // Use requestAnimationFrame for smooth looping
      animationId = requestAnimationFrame(animateVisualizer);
      // Get time-domain (waveform) data and frequency data from the analyser
      analyser.getByteTimeDomainData(dataArray);
      analyser.getByteFrequencyData(freqArray);

      // Calculate overall volume via RMS (root mean square) of waveform data
      let sumSquares = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const centeredVal = dataArray[i] - 128;  // center on 0
        sumSquares += centeredVal * centeredVal;
      }
      const rms = Math.sqrt(sumSquares / dataArray.length);
      const normalizedVolume = rms / 128;  // normalize RMS (0.0 to ~1.0)
      // Determine scale for pulsing (e.g., 1.0 base + up to 0.5 extra)
      const scale = 1 + normalizedVolume * 0.5;
      // Apply scaling transform to the GIF element
      pulseImg.style.transform = `scale(${scale})`;

      // Determine dominant frequency index (peak frequency)
      let maxIndex = 0;
      let maxValue = 0;
      for (let i = 0; i < freqArray.length; i++) {
        if (freqArray[i] > maxValue) {
          maxValue = freqArray[i];
          maxIndex = i;
        }
      }
      // Map dominant frequency index to a hue (0-360 degrees)
      const hue = (maxIndex / freqArray.length) * 360;
      // Apply a hue-rotate filter to shift the GIF's color according to frequency
      pulseImg.style.filter = `hue-rotate(${hue}deg)`;
    }
  </script>
</body>
</html>
